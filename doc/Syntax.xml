<?xml version="1.0" encoding="UTF-8"?>
<ex:Block xmlns:ex="http://elixir.mohiva.com">

	<ex:If expr="{% my.object.var.round(2) == 2.5 %}" />
	<ex:ElseIf expr="{% my.object.var.round(2) == 2.5 %}" />
	<ex:Else />

	<ex:Raw>

	</ex:Raw>

	<!--% A Elixir comment, it should be removed %-->

	<!-- A normal comment, it should be preserved -->

	<ex:Set name="var1"><inner /></ex:Set>
	<ex:Set name="var2" value="{% [(3 * index.toNumber()) => 1, 2, (3 * 4 + (1 + 2))] %}" />
	<ex:Set name="var2" value="all scalar values can be passed without an expression" />

	<ex:For var="user" in="{% users %}">
		<ex:Set name="name" value="{% user.name.whenNull('Default value') ?: 'Jon Doe' %}" />

		<!--
		Encoding will be ignored here, because the encode() method doesn't manipulate the value directly.
		It defines only the encoding strategy which will be used when the value is inserted into the template.
		And in this example the value will not directly be inserted into template, because the toLower() method
		returns a new Value object. Also note: the encode method should only be called as the last method.
		 -->
		{% name.encode('html').toLower() %} <!-- Doesn't work as expected -->
		{% name.toLower().encode('html') %} <!-- It works as expected -->

		<!--
		The same counts for the raw method. It should always be called as the last method before
		the is inserted into the template.
		-->
		{% name.raw().toLower() %} <!-- Doesn't work as expected -->
		{% name.toLower().raw() %} <!-- It works as expected -->

		<!-- Encodes all unsafe values in a block -->
		<ex:Encode strategy="html">
			{% name.encode('html') %}     <!-- Encoded as html -->
			{% tag.encode('xml') %}       <!-- Encoded as xml -->
			{% name %}                    <!-- Encoded as html -->
			{% name.raw() %}              <!-- Not encoded because it is marked as safe -->
		</ex:Encode>

		<!-- Calling encode() without an strategy uses the global encoding strategy -->
		{% name.encode() %}

		<!-- Calling encode()  -->



		<!--
		Safe values:
		============
		- All values which are defined directly in the template are automatically save and they will never be
		  encoded automatically. This doesn't mean that it isn't possible to encode such values. If you call
		  the encode() method on a safe value, it is also possible to encode it.
		- Values which are marked as raw.
		-->
		{% 1 %}
		{%
			name = 'Lucky Luke'
			name.toLower()
		%}
		{% var[1].raw() %}

		<!--
		Unsafe values:
		==============

		-->

		<!-- Values are always returned as new object -->
		{%
			name = 'Lucky Luke'
			toLower = name.toLower() <!-- toLower: lucky luke -->
			toUpper = name.toUpper() <!-- toUpper: LUCKY LUKE -->
			default = name           <!-- default: Lucky Luke -->
		%}

		{%
			name = user.name[index].split(' ').whenEmpty('Default value'.toLower())
				? 'Lucky Luke'
				: 'Jon' _ 'Doe'.toLower()
		%}

		$this->setVar('name', (new ObjectValue($this->getVar('user')))
			->getByProperty('name')
			->getByKey($this->getVar('index'))
			->split(' ')
			->whenEmpty((new StringValue('Default value'))->toLower())
			->toString() ?:  'Jon' . (new StringValue('Doe'))->toLower()
		);

		A raw '{% index %}'

		{% 'test {% index %} test' %}
		{% odd %}
		{% even %}
		{% first %}
		{% last %}

		You have {% numbers %} pieces of shit

	</ex:For>

	<ex:Foreach key="k" value="v" in="{% users %}">
		{% k %} {% v %}
	</ex:Foreach>

	<ex:Foreach in="{% users %}">
		{% key %} {% value %}
	</ex:Foreach>

</ex:Block>

<!--

Variables
=============
my
my.object
my.object.round(2)
my.object.round(2).isNotNull()
my.object.arrayVar.merge(my.object.otherArrayVar.keys())

Constants
==============
Global::CONSTANT
Class::CONSTANT
namespace.Class::CONSTANT.split('/')

Values
==============
1234
0.1234
-0.1234
+0.1234
true
false
null
[1, 2, 3 => 5]
{key: 'value'}
"a string"

Helpers(ExpressionHelper)
===============
mx:Date()

Operators
===============

unary
=====
! NOT (prefix notation)
- NEGATIVE (prefix notation)
+ POSITIVE (prefix notation)

binary
======
_  CONCAT
=  ASSIGN
== EQUAL
!= NOT_EQUAL
<  LESS
<= LESS_EQUAL
>  GREATER
>= GREATER_EQUAL
+  ADDITION
-  SUBTRACTION
/  DIVISION
*  MULTIPLICATION
%  MODULO
^  POWER
|| OR
&& AND

Every value is passed to an value object(autoboxing). this object contains methods like isNull(),
toNumber(), toArray(), toObject(), toString(), toBool(), toXML(), ... by default. Values are passed
to specific objects by the type of the value:
array  => ArrayValue
object => ObjectValue
int, float => NumberValue
string => StringValue
boolean => BooleanValue
xml => XMLValue

Values should only be autoboxed if an explicit method call follows after the value.

Autoboxed:
var.methodCall()

Not autoboxed:
var

Every object has specific methods to work with the value:
ArrayValue: join, merge, length, sort, keys, values, contains
ScalarValue: split, replace, format, upper, lower, reverse, length

It should be possible to register own value classes so that users can register its own implementations:
class CustomArrayValue extends ArrayValue {

}

class CustomValueFactory extends ValueFactory {

    public function createArrayValue($value) {

        return new CustomArrayValue($value);
    }
}

$config = new Config();
$config->setValueFactory(new CustomValueFactory());

-->

